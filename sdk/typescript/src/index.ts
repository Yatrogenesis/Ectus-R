/**
 * @ectus-r/plugin-sdk
 *
 * Official TypeScript SDK for building Ectus-R plugins
 * Generated by AION-R AI Engine
 */

// Core Plugin Types
export interface Plugin {
  name: string;
  version: string;
  description?: string;
  generators?: CodeGenerator[];
  analyzers?: Analyzer[];
  transformers?: Transformer[];
  templates?: TemplateGenerator[];
}

// Code Generation
export interface CodeGenerator {
  name: string;
  version: string;
  supportedLanguages: string[];
  generate(context: PluginContext): Promise<GeneratedFiles>;
}

export interface TemplateGenerator {
  name: string;
  description?: string;
  generate(context: PluginContext): Promise<GeneratedFiles>;
}

// Analysis
export interface Analyzer {
  name: string;
  category: AnalyzerCategory;
  analyze(context: PluginContext): Promise<AnalysisResult>;
}

export enum AnalyzerCategory {
  Security = 'security',
  Performance = 'performance',
  Quality = 'quality',
  Style = 'style',
}

export interface AnalysisResult {
  issues: Issue[];
  score: number;
  recommendations?: Recommendation[];
}

export interface Issue {
  severity: 'low' | 'medium' | 'high' | 'critical';
  category: string;
  file: string;
  line?: number;
  column?: number;
  description: string;
  suggestedFix?: string;
}

export interface Recommendation {
  title: string;
  description: string;
  impact: 'low' | 'medium' | 'high';
  effort: 'low' | 'medium' | 'high';
}

// Code Transformation
export interface Transformer {
  name: string;
  description: string;
  transform(context: PluginContext): Promise<TransformResult>;
}

export interface TransformResult {
  modifiedFiles: ModifiedFile[];
  summary: string;
}

export interface ModifiedFile {
  path: string;
  originalContent: string;
  newContent: string;
  changes: Change[];
}

export interface Change {
  line: number;
  type: 'addition' | 'deletion' | 'modification';
  description: string;
}

// Plugin Context
export interface PluginContext {
  // Project Information
  getProjectPath(): string;
  getRequirements(): Requirements;
  getArchitecture(): SystemArchitecture;
  getConfiguration(): PluginConfig;

  // File Operations
  getGeneratedFiles(): GeneratedFile[];
  readFile(path: string): Promise<string>;
  fileExists(path: string): Promise<boolean>;

  // AI Services
  invokeAI(prompt: string, options?: AIOptions): Promise<string>;
  analyzeCode(code: string, language: string): Promise<CodeAnalysis>;

  // Logging
  log(level: LogLevel, message: string, metadata?: Record<string, unknown>): void;

  // Utilities
  resolveTemplate(name: string): Promise<string>;
  formatCode(code: string, language: string): Promise<string>;
}

export type LogLevel = 'debug' | 'info' | 'warn' | 'error';

export interface AIOptions {
  model?: string;
  temperature?: number;
  maxTokens?: number;
  systemPrompt?: string;
}

export interface CodeAnalysis {
  complexity: number;
  maintainability: number;
  securityScore: number;
  issues: Issue[];
  metrics: CodeMetrics;
}

export interface CodeMetrics {
  linesOfCode: number;
  cyclomaticComplexity: number;
  cognitiveComplexity: number;
  maintainabilityIndex: number;
}

// Requirements and Architecture
export interface Requirements {
  projectName: string;
  description: string;
  functionalRequirements: string[];
  nonFunctionalRequirements: string[];
  targetLanguage: string;
  framework?: string;
  constraints: Constraints;
}

export interface Constraints {
  maxFileSize?: number;
  performanceRequirements?: PerformanceRequirements;
  securityRequirements?: SecurityRequirements;
  compatibilityRequirements?: CompatibilityRequirements;
}

export interface PerformanceRequirements {
  maxLatencyMs?: number;
  minThroughputRps?: number;
  maxMemoryMb?: number;
  maxCpuPercent?: number;
}

export interface SecurityRequirements {
  encryptionRequired: boolean;
  authenticationType?: string;
  authorizationModel?: string;
  complianceStandards: string[];
}

export interface CompatibilityRequirements {
  minRuntimeVersion?: string;
  targetPlatforms: string[];
  requiredDependencies: string[];
  excludedDependencies: string[];
}

export interface SystemArchitecture {
  pattern: ArchitecturePattern;
  components: Component[];
  connections: Connection[];
  layers: Layer[];
}

export enum ArchitecturePattern {
  Microservices = 'microservices',
  Monolithic = 'monolithic',
  Serverless = 'serverless',
  EventDriven = 'event-driven',
  Layered = 'layered',
  Hexagonal = 'hexagonal',
  MVC = 'mvc',
  MVVM = 'mvvm',
  Clean = 'clean',
}

export interface Component {
  name: string;
  type: string;
  responsibilities: string[];
  dependencies: string[];
  language?: string;
}

export interface Connection {
  from: string;
  to: string;
  protocol: string;
  description?: string;
}

export interface Layer {
  name: string;
  components: string[];
}

// Generated Files
export interface GeneratedFiles {
  files: GeneratedFile[];
  metadata?: GenerationMetadata;
}

export interface GeneratedFile {
  path: string;
  content: string;
  language: string;
  purpose?: string;
  dependencies?: string[];
  exports?: string[];
}

export interface GenerationMetadata {
  generatorName: string;
  generatorVersion: string;
  timestamp: string;
  totalFiles: number;
  totalLinesOfCode: number;
}

// Plugin Configuration
export interface PluginConfig {
  enabled: boolean;
  options: Record<string, unknown>;
  customSettings?: Record<string, unknown>;
}

// Plugin Builder
export class PluginBuilder {
  private plugin: Partial<Plugin> = {};

  constructor(name: string, version: string) {
    this.plugin.name = name;
    this.plugin.version = version;
  }

  withDescription(description: string): this {
    this.plugin.description = description;
    return this;
  }

  addGenerator(generator: CodeGenerator): this {
    if (!this.plugin.generators) {
      this.plugin.generators = [];
    }
    this.plugin.generators.push(generator);
    return this;
  }

  addAnalyzer(analyzer: Analyzer): this {
    if (!this.plugin.analyzers) {
      this.plugin.analyzers = [];
    }
    this.plugin.analyzers.push(analyzer);
    return this;
  }

  addTransformer(transformer: Transformer): this {
    if (!this.plugin.transformers) {
      this.plugin.transformers = [];
    }
    this.plugin.transformers.push(transformer);
    return this;
  }

  addTemplate(template: TemplateGenerator): this {
    if (!this.plugin.templates) {
      this.plugin.templates = [];
    }
    this.plugin.templates.push(template);
    return this;
  }

  build(): Plugin {
    if (!this.plugin.name || !this.plugin.version) {
      throw new Error('Plugin must have a name and version');
    }
    return this.plugin as Plugin;
  }
}

// Base Classes for Convenience
export abstract class BaseCodeGenerator implements CodeGenerator {
  abstract name: string;
  abstract version: string;
  abstract supportedLanguages: string[];

  abstract generate(context: PluginContext): Promise<GeneratedFiles>;

  protected createFile(path: string, content: string, language: string): GeneratedFile {
    return { path, content, language };
  }
}

export abstract class BaseAnalyzer implements Analyzer {
  abstract name: string;
  abstract category: AnalyzerCategory;

  abstract analyze(context: PluginContext): Promise<AnalysisResult>;

  protected createIssue(
    severity: Issue['severity'],
    category: string,
    file: string,
    description: string,
    options?: Partial<Issue>
  ): Issue {
    return {
      severity,
      category,
      file,
      description,
      ...options,
    };
  }
}

export abstract class BaseTransformer implements Transformer {
  abstract name: string;
  abstract description: string;

  abstract transform(context: PluginContext): Promise<TransformResult>;

  protected createModifiedFile(
    path: string,
    originalContent: string,
    newContent: string,
    changes: Change[]
  ): ModifiedFile {
    return {
      path,
      originalContent,
      newContent,
      changes,
    };
  }
}

// Utility Functions
export function createPlugin(config: {
  name: string;
  version: string;
  description?: string;
  generators?: CodeGenerator[];
  analyzers?: Analyzer[];
  transformers?: Transformer[];
  templates?: TemplateGenerator[];
}): Plugin {
  return config as Plugin;
}

export function validatePlugin(plugin: Plugin): { valid: boolean; errors: string[] } {
  const errors: string[] = [];

  if (!plugin.name) errors.push('Plugin must have a name');
  if (!plugin.version) errors.push('Plugin must have a version');

  const hasCapabilities =
    (plugin.generators && plugin.generators.length > 0) ||
    (plugin.analyzers && plugin.analyzers.length > 0) ||
    (plugin.transformers && plugin.transformers.length > 0) ||
    (plugin.templates && plugin.templates.length > 0);

  if (!hasCapabilities) {
    errors.push('Plugin must have at least one generator, analyzer, transformer, or template');
  }

  return {
    valid: errors.length === 0,
    errors,
  };
}

// Export everything
export default {
  PluginBuilder,
  BaseCodeGenerator,
  BaseAnalyzer,
  BaseTransformer,
  createPlugin,
  validatePlugin,
};
